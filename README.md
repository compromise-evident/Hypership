<!---
Hyperspeed Authorship variant using 1.2kB
disposable public files for user authentication.
-->



### Lightweight authentication for gargantuan user base (6,570-bit encryption)

<p align="center">
  <img src="https://github.com/compromise-evident/Hypership/blob/main/Other/Terminal.png">
</p>

[No reversal shortcuts means no inherent solutions.](https://github.com/compromise-evident/Hypership/blob/main/Other/Perfect%20secrecy%20and%20P!%3DNP%20proof.pdf) | [Auditing in the browser?](https://coliru.stacked-crooked.com/a/095466ff5fac5063)

# How it works; infinitely splicing finitude

Number files are 150 Bytes (72-character numbers shared as 150-Byte strings, those extra characters are space where a new number is constructed over time--one bit per event. Study Authorship thoroughly before studying the following. Here, splicing works like a zipper--splicing finite pre-computed nested chains using the infinity of Authorship. 504 authentication events are pre-generated and nested right-to-left with automatic numbers concatenated with 2 ciphertext then hashed. <br/>

After 504 events, 504 bits represent the full new 72-character number; 1 key per event reveals the next bit through the automatic message. Hypership is without user messages but you can give yes-or-no permission for authentication, handover, and withdrawal, without authenticating data, transaction quantity, its itinerary, or handover destination numbers. <br/>

However, modifying parties can provide Authorship or AuthorshipFemto numbers in case verifying parties occasionally require data authentication. This way, all (16) Authorship abilities and features always apply; verifying parties retain multiple numbers of yours--each capable of different things. And as Authorship variants with user messages keep getting smaller, you can pair Hypership with any and all numbers.

<p align="center">
  <img src="https://github.com/compromise-evident/Hypership/blob/main/Other/Main%20documentation%20image.png">
</p>

For further clarity, think of Hypership as Authorship with the following 3 major changes:
* The function list (ordered list of multiple individual ciphertext items) has been reduced from 1,008 down to only 2 functions per list. That's enough for a 1-bit message per event (rather than an 80-character message per event as seen in Authorship--having 126 possibilities per character, and 95 by default.) ...And with single message bits over time, Hypership represents a new number. <br/>

* Meanwhile, the number (72 characters) changes for each event as seen in Authorship. But how can these numbers be represented if ALL (2) functions in the list are used for automatic messages? (Authorship has a partition in the function list reserved for representing a new number.) ...This is the purpose of finite pre-generated nesting; Hypership numbers (the 1st 72-character portions) **are not only the hash of a function list, but also the hash of another pre-generated number.** It is extracted directly from the input string to the number (numbers are hash.) <br/>

* The Hypership.number file actually contains 2 72-character numbers; the 1st one changes for each event as seen in Authorship, and the second is being assembled 1 bit per event. Once completely assembled (504 events,) it replaces the first number and the second is cleared for another assembly.
